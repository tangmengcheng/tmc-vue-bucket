{"version":3,"file":"reactivity.esm-bundler.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts"],"sourcesContent":["export const isObject = (value) => typeof value === 'object' && value !== null\n\nexport const extend = Object.assign","export function effect(fn, options:any = {}) {\n    const effect = createReactiveEffect(fn, options)\n\n    if (!options.lazy) {\n        effect() // 默认effect会先执行一次\n    }\n\n    return effect\n}\n\nlet uid = 0\nlet activeEffect; // 存储当前的effect\nconst effectStack = [] // 栈：解决了key对应的effect是正确的\nfunction createReactiveEffect(fn, options) {\n    const effect = function reactiveEffect() {\n        if(!effectStack.includes(effect)) { // 防止重复频繁刷新\n            try { // fn函数执行过程可能发生异常\n                console.log('todo....')\n                effectStack.push(effect)\n                activeEffect = effect\n                return fn()\n            } finally {\n                effectStack.pop()\n                activeEffect = effectStack[effectStack.length - 1]\n            }\n        }\n    }\n    effect.id = uid // 制作一个effect标识，用于区分effect，源码用于排序\n    effect._isEffect = true // 用于标识这个是响应式effect\n    effect.raw = fn // 暴露effect对应的原函数\n    effect.options = options // 在effect上保存用户的属性\n\n    return effect\n}\n\nconst targetMap = new WeakMap()\n/**\n * 让对象中的某个属性与effect关联起来\n * @param target 目标对象\n * @param type 操作类型\n * @param key 属性\n */\nexport function track(target, type, key) { // 可以拿到当前的effect\n    // console.log(target, type, key, activeEffect)\n    if(activeEffect === undefined) { // 此属性不用收集依赖，因为没在effect中使用\n        return\n    }\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n        depsMap.set(key, (dep = new Set())) // set可以去重，一个属性有可能对应多个effect\n    }\n    if (!dep.has(activeEffect)) {\n        dep.add(activeEffect)\n    }\n    console.log(targetMap)\n}\n\n// 为什么要用栈来存当前effect？\n// 函数调用是一个栈型结构\n// effect(()=> { // effect1\n//     state.name\n//     effect(() => { // effect1\n//         state.age\n//     })\n//     state.address\n// })","// 是不是仅读的，没有set，会报异常\n// 是不是深度的\n\nimport { extend, isObject } from \"@vue/shared\"\nimport { track } from \"./effect\"\nimport { TrackOpTypes } from \"./operators\"\nimport { reactive, readonly } from \"./reactive\"\n\nconst get = createGetter()\nconst shallowGet = createGetter(false, true)\nconst readonlyGet = createGetter(true)\nconst shallowReadonlyGet = createGetter(true, true)\n\nconst set = createSetter()\nconst shallowSet = createSetter(true)\n\nexport const mutableHandlers = {\n    get,\n    set\n}\nexport const shallowReactiveHandlers = {\n    get: shallowGet,\n    shallowSet\n}\nconst readonlyObj = {\n    set: (target, key) => {\n        console.warn(`set ${target} on key ${key} failed`)\n    }\n}\nexport const readonlyHandlers = extend({\n    get: readonlyGet  \n}, readonlyObj)\nexport const shallowReadonlyHandles = extend({\n    get: shallowReadonlyGet\n}, readonlyObj)\n\n// 拦截获取功能\nfunction createGetter (isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        // proxy + reflect\n        // 后续Object上的方法，会被迁移到 Reflect上  Reflect.getProperty)\n        // 以前target[key] = value 方法设置值可能会失败，但是不会报异常，也没有返回值\n        // Reflect 方法具备返回值\n        const res = Reflect.get(target, key, receiver) // target[key]\n\n        if (!isReadonly) {\n            // 收集依赖，等会数据变化后更新对应的试图\n            console.log('执行effect时会取值，收集effect')\n            // 找到对象上哪个属性与effect关联。并记录是什么操作\n            track(target, TrackOpTypes.GET, key)\n        }\n        if (shallow) {\n            return res\n        }\n        if (isObject(res)) { // vue2 是一上来就递归，vue3是当前取值时会进行代理。称为懒代理\n            return isReadonly ? readonly(res) : reactive(res)\n        }\n        return res\n    }\n}\n// 拦截设置功能\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        const result = Reflect.set(target, key, value, receiver) // target[key] = value\n        \n        // 当数据更新时，通知对应属性的effect重新执行\n\n        return result\n    }\n}","import { isObject } from '@vue/shared'\n\nimport {\n    mutableHandlers,\n    shallowReactiveHandlers,\n    readonlyHandlers,\n    shallowReadonlyHandles\n} from './baseHandlers'\n\nexport function reactive(target) {\n    return createReactiveObject(target, false, mutableHandlers)\n}\n\nexport function shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers)\n}\n\nexport function readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers)\n}\n\nexport function shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandles)\n}\n\nconst reactiveMap = new WeakMap() // 会自动垃圾回收，不会造成内存泄露，存储的key只能是对象\nconst readonlyMap = new WeakMap()\n\n/**\n * 柯里化，new Proxy() 最核心的需要拦截数据的读取和修改 -> get set\n * @param target 目标对象\n * @param isReadonly 是否只读\n * @param baseHandlers 处理器函数\n */\nexport function createReactiveObject(target, isReadonly, baseHandlers) {\n    // 如果目标不是对象，没法拦截，reactive这个api只能拦截对象\n    if(!isObject(target)) {\n        return target\n    }\n\n    // 如果某个对象已经被代理过了，就不要再代理了(可能一个对象被代理是深度，又被仅读代理)\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap\n\n    const existProxy = proxyMap.get(target)\n    if (existProxy) {\n        return existProxy // 如果已经被代理了 直接返回即可\n    }\n\n    const proxy = new Proxy(target, baseHandlers)\n\n    proxyMap.set(target, proxy) // 将要代理的对象和对应代理结果缓存起来\n\n    return proxy\n}"],"names":[],"mappings":"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"}